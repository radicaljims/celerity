import Html exposing (..)
import Html.Attributes exposing (style)
import Html.App as App
import Html.Events exposing (..)

import List exposing (..)

-- jfs: this is just a comment to myself as I mentally work through
-- how the core Elm code that manages the model interacts with the
-- outside world (CSS, Javascript, etc.)
-- import Task -- need to ask the outside world what the time is
            -- there's probably a slick way to put the timeout
            -- in a CSS fade, but I don't know CSS!
            -- and of course we'd have to generate a signal
            -- to tell Elm to update its model, so hmmm.

import Time exposing (Time, second)

import CelerityTypes exposing (..)

import Styles

-- jfs : pretty cool how it looks like time has units, huh?
defaultTimeout : Time
defaultTimeout = 3 * second

-- jfs: the following types are the core of the application
--
-- type alias Model = List Copy
-- view : Model -> Html Action
-- update : Action -> Model -> Model
--
-- We've mostly got MVC factored out, but we need to 'factor them back in'
-- to get a running program. This is what App.beginnerProgram does for us.
--
-- Under the hood it will track delivering new Actions to the update function
-- and handle twiddling the view.
--
-- At the end of the day though it should just boil down to plain old function
-- composition. It'd be interesting to take a look at the source sometime.

main : Program Never
main =
  App.beginnerProgram
     { model = emptyModel
     , view = view
     , update = update
     }
  -- App.programWithFlags
  --    { init = init
  --    , view = view
  --    , update = update
  --    , subscriptions = \_ -> Sub.none
  --    }

-- jfs: Our model is just a list of copies. Think we need anything more complex?
type alias Model = List Copy

-- jfs: The initial state of our application - no copies!
emptyModel : Model
emptyModel = []

-- jfs: The type of actions we can perform, usually on our model.
-- Add, Remove, and Pop should be pretty explanatory.
-- Tick is there just to allow our update function to handle events
-- generated by a timer.
type Action
  = Tick
  | Add Copy
  | Remove Id
  | Pop

-- jfs: A little convenience to go with our 'Add Copy' button
fakeCopy : Action
fakeCopy = Add {kind = "nah", title = "greets", message = "hi there", id = -1, started = (0 * second)}

-- jfs: Another convenience, this time for our 'Remove Copy' button
popCopy : Action
popCopy = Pop

-- jfs: Updates the model (List Copy) based on the given action
update : Action -> Model -> Model
update action model =
  case action of
    -- jfs: As I indicated above, this handles timeout events.
    -- It doesn't do anything yet because I'm not sure how best to go
    -- about aging out copies
    Tick -> model
            -- So, I'd kind of like to age things out based purely on ticks,
            -- but to guarantee consistent lifetimes I'd have to cache Adds/Removes
            -- and do them in this handler. Which isn't so cool.
            --
            -- I assume the JS Copyr just uses setTimeout or something?
            -- Which we can do with Tasks and such, but it's not very elegant.
            --
            -- Another thought: assuming a CSS fadeout, maybe it's not a big
            -- deal if the DOM and our Elm model are occasionally inconsistent?
            -- Then I'd just have to ensure the number of ticks a toast
            -- gets is greater (but not too much!) than the CSS fadeout

    -- jfs: Add a new toast. But before we do, set its 'id' to
    --  be its 'index' in the list
    Add toast ->
      {toast | id = length model } :: model

    -- jfs: Remove the toast corresponding to a given id
    -- by filtering it out of the list. I've imported everything
    -- in the List module so we can freely reference 'filter',
    -- 'take', 'map', etc.
    Remove id ->
      filter (\toast -> toast.id /= id) model

    -- jfs: Pop off the bottom (nth element) of the list by
    -- simply taking the first (n - 1) elements and dropping the nth
    -- Could also implement it in terms of filter:
    --   filter (\toast -> toast.id /= (length model)) model
    Pop ->
      take ((List.length model) - 1) model

-- jfs: The bit of code that knows how to display a toast
-- It creates a div tag with no styles and one child,
-- a span containing a text element.
-- See this documentation for more about the Html module:
-- http://package.elm-lang.org/packages/elm-lang/html/1.1.0/Html
renderCopy : Copy -> Html Action
renderCopy toast =
  div
    [ style Styles.copy ] -- The 'toast' style is defined in Styles.elm
    [ span
        []
        [text toast.message]
    ]

-- jfs: The view that knows how to render
-- a complete model. All it really needs to do is
-- map the renderCopy method over the model!
view : Model -> Html Action
view model =
  div
    []
    (header :: (map renderCopy model))

-- jfs: A convenience method that generates a button with
-- some text that generates an Action on click.
-- This is actually a little subtle! (See the inline
-- comment)
makeButton : Action -> String -> Html Action
makeButton action btn_text =
  button
    [onClick action] -- jfs: This is very cool - when the button is clicked, Elm will deliver the corresponding
    [text btn_text]  -- action to the update() function, which will in turn trigger a call to view()!

-- jfs: Just a div container with some buttons that let the
-- user manipulate the state of the model. When this program
-- grows up, the state will be manipulated by websockets and the like.
header : Html Action
header =
  div
    [ style Styles.center] -- The 'center' style is defined in Styles.elm
    [ (makeButton fakeCopy "Add Copy")   -- jfs: Like I said above, when clicked Elm will deliver the fakeCopy action
    , (makeButton popCopy "Remove Copy") -- to the update function, causing the 'Add' pattern to match and prepend the
    ]                                      -- fake toast to the model. Similarly the 'popCopy' action will match the
                                           -- 'Pop' pattern and cause the bottom toast to be removed.

-- jfs: Anything that can generate an Action can be used to manipulate our model. This includes
-- (especially!) streams like keyboard events and websocket notifications.
--
-- Obviously keyboard events and websocket notifications aren't Actions by default, but
-- all we need to do is write a single function that can convert one event or one notification
-- to an Action.
--
-- Then we can simply 'map' that function over the stream and Bob's your uncle! A stream of
-- copies ready to feed into our update() function.
